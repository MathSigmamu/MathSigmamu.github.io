<html>
  <head>
    <meta charset="UTF-8">
    <title>testing</title>
    <style>
    			body { margin: 0; }
    			canvas { display: block; }
    		</style>

  </head>
  <body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r122/three.min.js"></script>
<script src ="https://threejs.org/examples/js/controls/OrbitControls.js"></script>>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js" integrity="sha512-LF8ZB1iTwi4Qvkm4pekHG4a437Y9Af5ZuwbnW4GTbAWQeR2E4KW8WF+xH8b9psevV7wIlDMx1MH9YfPqgKhA/Q==" crossorigin="anonymous"></script>
<script src ="HDRCubeTextureLoader.js"></script>
<script src ="RGBELoader.js"></script>
    </script>

    </script>
    <script >

let container;
let scene;
let camera;
let render;
let ambientlight;
let light;
  let MCsolver;
var shedW =2860;
var shedD = 5100;
var shedH=2400;
var propH = 1.00;
var overhang =100;
var MaterialThickness =25;
var base, basegeometry, basemesh;
var side1,side1geometry,side1mesh;
var lside,lsidegeometry,lsidemesh;
var side2, side2geometry,side2mesh;
var doorW, doorH;
var toothw =50;
var hdrCubeMap;
doorW = 762;
doorH = 1981;
var windowW = 1000;
var windowH = 200;
var wireframe = true;
var lineMat;
var partMode = true;
var partcamera;

var controls;
var meshColor =  new THREE.MeshPhongMaterial();
meshColor.shadowSide= THREE.DoubleSide;
meshColor.color = new THREE.Color( '#C19A6B');
meshColor.side = THREE.DoubleSide;

meshColor.wireframe= false;
meshColor.wireframeLinewidth = 10;
init();
function onLoad(){

}
      function init(){

createGUI();
const aotex =  new THREE.TextureLoader().load('mattext/ao.jpg' );
const roughtex = new THREE.TextureLoader().load('mattext/rough.jpg' );
const difftex = new THREE.TextureLoader().load('plywood2.jpg' );
const norm = new THREE.TextureLoader().load('mattext/norm.jpg' );
const btex = new THREE.TextureLoader().load('mattext/background.jpg' );
//texture.wrapT = THREE.RepeatWrapping;
//texture.mapping = THREE.CubeUVReflectionMapping;
//texture.needsUpdate = true;
lineMat = new THREE.LineBasicMaterial( { color: 000000	, linewidth: 2 } );
var hdrCubeRenderTarget;
const hdrUrls = [ 'scene.hdr' ];
hdrCubeMap = new THREE.HDRCubeTextureLoader()
					.setPath( './' )
					.setDataType( THREE.UnsignedByteType )
					.load( hdrUrls, function () {

						hdrCubeRenderTarget = pmremGenerator.fromCubemap( hdrCubeMap );

						hdrCubeMap.magFilter = THREE.LinearFilter;
						hdrCubeMap.needsUpdate = true;

					} );

//texture.repeat.set(5, 5);

        meshColor = new THREE.MeshPhongMaterial(  );
        container = document.createElement( 'div' );
        meshColor.side = THREE.DoubleSide;
        meshColor.color.convertSRGBToLinear();
        meshColor.roughnessMap = roughtex;
        meshColor.aoMap = aotex;
        meshColor.normalMap = norm
        meshColor.map = difftex;
      //  meshColor.envMap =btex

        				//document.body.appendChild( container );
width = window.innerWidth;
height = window.innerHeight;
        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000000 );
        partcamera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 0, 1000 );
        camera.position.z = 0;
        camera.position.y=-1000;
			camera.position.set( 100, 1000, 2500 );
      render = new THREE.WebGLRenderer( { antialias: true } );
      console.log(render)
      render.setSize(window.innerWidth, window.innerHeight);
      				render.setPixelRatio( window.devicePixelRatio );
      				render.setSize( window.innerWidth, window.innerHeight );
              document.body.appendChild(render.domElement);

      scene = new THREE.Scene();



      		//	scene.background = btex;

            light = new THREE.DirectionalLight( 0xffffff );
            //			light.position.set( 0.5, 0.5, 1 );
            	//		scene.add( light );

            			ambientLight = new THREE.AmbientLight( '#FFFFFF'  );

 controls = new THREE.OrbitControls( camera, render.domElement );
controls.update();
createGeom();
      }

function createGeom(){
  scene = new THREE.Scene();
  scene.add(ambientLight);
  scene.background = new THREE.Color(   0xffffff );

  //scene.add(light);
  var rlength = Math.sqrt(Math.pow(shedH*(1-propH),2)+Math.pow(shedW/2,2))+overhang;
  var points = [new THREE.Vector2(-(MaterialThickness/2)-shedW/2,-(MaterialThickness/2)-shedD/2),new THREE.Vector2((MaterialThickness/2)+shedW/2,-(MaterialThickness/2)-shedD/2),new THREE.Vector2((MaterialThickness/2)+shedW/2,(MaterialThickness/2)+shedD/2),new THREE.Vector2(-(MaterialThickness/2)-shedW/2,(MaterialThickness/2)+shedD/2)];
  var points2 =[new  THREE.Vector2(-shedW/2,-shedH/2),new THREE.Vector2(-(doorW/2),-shedH/2),new THREE.Vector2(-(doorW/2),(-shedH/2)+doorH),new THREE.Vector2(doorW/2,(-shedH/2)+doorH),new THREE.Vector2(doorW/2,-(shedH/2)), new THREE.Vector2(shedW/2,-(shedH/2)),new THREE.Vector2(shedW/2,(-shedH/2)+shedH*propH),new THREE.Vector2(0,shedH/2),new THREE.Vector2(-shedW/2,(-shedH/2)+shedH*propH)]
  var points3 = inserts(new  THREE.Vector2((-shedD/2)+MaterialThickness,0),new THREE.Vector2((shedD/2)-MaterialThickness,0),new THREE.Vector2((shedD/2)-MaterialThickness,shedH*propH),new THREE.Vector2((-shedD/2)+MaterialThickness,shedH*propH),true,true,false,true)
  var points4 = [new  THREE.Vector2(-shedW/2,-(shedH/2)),new THREE.Vector2(-shedW/2,(-shedH/2)+shedH*propH),new THREE.Vector2(0,shedH/2),new THREE.Vector2(shedW/2,(-shedH/2)+shedH*propH),new THREE.Vector2(shedW/2,-shedH/2)]
  var roof1P = [new  THREE.Vector2((-shedD/2)-overhang,0),new THREE.Vector2((shedD/2)+overhang,0),new THREE.Vector2((shedD/2)+overhang,rlength+MaterialThickness),new THREE.Vector2((-shedD/2)-overhang,rlength+MaterialThickness)]
  var roof2P = [new  THREE.Vector2((-shedD/2)-overhang,0),new THREE.Vector2((shedD/2)+overhang,0),new THREE.Vector2((shedD/2)+overhang,rlength),new THREE.Vector2((-shedD/2)-overhang,rlength)]
var transvec = new THREE.Vector3(0-shedW/2,shedH-(shedH*propH),0);
var top = new THREE.Vector3(0,shedH,0);
var edge = new THREE.Vector3(0,shedH*propH,0);
transvec.subVectors(top,edge)
transvec.normalize();
//transvec.multiplyScalar(MaterialThickness);


var prts = [];
  base = new THREE.Shape(points);
  var h= createHoles(new THREE.Vector2(-MaterialThickness-shedW/2,-MaterialThickness-shedD/2),new THREE.Vector2(MaterialThickness+shedW/2,-MaterialThickness-shedD/2),new THREE.Vector2(MaterialThickness+shedW/2,MaterialThickness+shedD/2),new THREE.Vector2(-MaterialThickness-shedW/2,MaterialThickness+shedD/2),true,true,true,true)
base.autoClose=true;
base.holes =h;
  side1 = new THREE.Shape(points2);
  side2 = new THREE.Shape(points4);
  var s2 = new THREE.Shape(points4);
  var r1 = new THREE.Shape(roof1P);
  var r2 = new THREE.Shape(roof2P)
  lside = new THREE.Shape(points3);
  const extrudeSettings = { depth: MaterialThickness, bevelEnabled: false, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };
  const extrudeSettingsrev = { depth: -MaterialThickness, bevelEnabled: false, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };
  console.log(base);
  prts.push(base);
  prts.push(side1);
  prts.push(lside);
  prts.push(s2);
  prts.push(r1);
  prts.push(r2);
  prts.push(lside);




if(partMode==true){
  console.log(prts)
layout(prts);
return;
}
else{


side1geometry = new THREE.ExtrudeBufferGeometry(side1,extrudeSettings);
var sg2 = new THREE.ExtrudeBufferGeometry(s2,extrudeSettings);

var rg1 = new THREE.ExtrudeBufferGeometry(r1,extrudeSettingsrev);
var rg2 = new THREE.ExtrudeBufferGeometry(r2,extrudeSettings);

  basegeometry = new THREE.ExtrudeBufferGeometry( base, extrudeSettings );
  lsidegeometry = new THREE.ExtrudeBufferGeometry(lside, extrudeSettings);

if(wireframe){
  basemesh =ConvWire( basegeometry);
  side1mesh = ConvWire(side1geometry);
  lsidemesh = ConvWire(lsidegeometry);
  sm2 = ConvWire(sg2);
  rm1 = ConvWire(rg1);
  rm2 = ConvWire(rg2);
}
else{
  normalizeUVs(basegeometry);
  normalizeUVs(side1geometry);
  normalizeUVs(lsidegeometry);
  normalizeUVs(sg2);
  normalizeUVs(rg1);
  normalizeUVs(rg2);


  basemesh = new THREE.Mesh( basegeometry, meshColor );
  side1mesh = new THREE.Mesh(side1geometry,meshColor);
  lsidemesh = new THREE.Mesh(lsidegeometry,meshColor);
  sm2 = new THREE.Mesh(sg2,meshColor);
  rm1 = new THREE.Mesh(rg1,meshColor);
  rm2 = new THREE.Mesh(rg2,meshColor);
}
//// Repositioning ////
side1mesh.position.z = -shedD/2;
lsidemesh.rotation.y = Math.PI/2;
sm2.position.y=shedH/2;
side1mesh.position.y=shedH/2;
lsidemesh.position.x = (-shedW/2)+MaterialThickness;
var lsidemesh2 = lsidemesh.clone();
lsidemesh2.position.x = (shedW/2)-(MaterialThickness*2);
var vx = new THREE.Vector3(1,0,0);
basemesh.rotation.x = Math.PI/2;
sm2.position.z = (shedD/2)-MaterialThickness;
rm1.rotateY( Math.PI/2);
rm1.rotateX(  -Math.atan((shedW/2)/(shedH*(1-propH)))-Math.PI);
rm1.position.y=(shedH);
rm2.rotateY( Math.PI/2);
rm2.rotateX(  Math.atan((shedW/2)/(shedH*(1-propH)))+Math.PI);
rm2.position.y=(shedH);
rm1.translateOnAxis(transvec,-25);

//// Wireframe Rendering////


scene.add(lsidemesh);
scene.add(side1mesh);
scene.add(rm1);
scene.add(rm2);
scene.add(lsidemesh2)
scene.add(sm2);
scene.add(basemesh);

}
}



function layout(list){

for (var i = 0; i < list.length; i++) {

console.log(list[i]);

  var geotest = new THREE.ShapeGeometry(list[i]);
  geotest.computeBoundingBox();
  var min = geotest.boundingBox.min;
  var max = geotest.boundingBox.max;
  var middle = new THREE.Vector3().subVectors(max,min);
  var scale = (window.innerWidth/(list.length+1))/Math.max(max.x-min.x,max.y-min.y);

  if(list[i].holes.length>0&& wireframe){
    for(var u =0; u<list[i].holes.length;u++){
      geotest =  new THREE.ShapeGeometry(list[i].holes[u]);
      geotest.scale(scale,scale,scale);
    geotest = ConvWire(geotest);
    geotest.position.x =  (window.innerWidth/list.length/2)-(window.innerWidth/2)+((window.innerWidth/list.length)*i+1);
      scene.add(geotest);
    }
    list[i].holes.length =0;
    console.log(base);
    geotest = new THREE.ShapeGeometry(list[i]);
  }


  geotest.scale(scale,scale,scale);
  geotest.computeBoundingBox();
  min = geotest.boundingBox.min;
  if(wireframe){

  geotest = ConvWire(geotest);


  }
  else{
    console.log(typeof(geotest));

    geotest = new THREE.Mesh(geotest,meshColor)
    console.log(geotest);
normalizeUVs(geotest.geometry);
console.log(geotest);
  }
  geotest.position.x= (window.innerWidth/list.length/2)-(window.innerWidth/2)+((window.innerWidth/list.length)*i+1);

  scene.add(geotest);








}

}

function ConvWire(geo ){
  var geo2 = new THREE.EdgesGeometry(geo);
  var Wf = new THREE.LineSegments( geo2, lineMat );


  return Wf
}

function inserts(start1,end1,start2,end2,b1,b2,b3,b4){
var dir = new THREE.Vector2();
var mid = new THREE.Vector2();
dir.subVectors(end1,start1);
mid.addVectors(end1,start1);
mid.multiplyScalar(0.5);
var length= dir.length();
dir.normalize();
var points=[];
var normalv = new THREE.Vector2(dir.y,-1*dir.x);
normalv.normalize();
points.push(start1);
if(b1){
  var max = Math.floor((((length/2)-(2*toothw))-(toothw+MaterialThickness))/toothw);
    for(var i=max;i>0;i--){
      if(i%5==0){
      //  points.push( new THREE.Vector2(mid.x-(dir.x*(i*toothw))))


    points.push(new THREE.Vector2(mid.x-(dir.x*((i*toothw)+MaterialThickness+toothw)),mid.y-(dir.y*((i*toothw)+MaterialThickness+toothw))));
    points.push(new THREE.Vector2(mid.x-(dir.x*((i*toothw)+MaterialThickness+toothw))+(normalv.x*MaterialThickness*2),mid.y-(dir.y*i*toothw)+(normalv.y*MaterialThickness*2)));
    points.push(new THREE.Vector2(mid.x-(dir.x*(((i-1)*toothw)+MaterialThickness+toothw))+(normalv.x*MaterialThickness*2),mid.y-(dir.y*((i*toothw)-toothw))+(normalv.y*MaterialThickness*2)));
    points.push(new THREE.Vector2(mid.x-(dir.x*(((i-1)*toothw)+MaterialThickness+toothw)),mid.y-(dir.y*(((i-1)*toothw)+MaterialThickness+toothw))));




}
  }
  for (var i = toothw+MaterialThickness; i <(length/2)-(2*toothw); i+=toothw) {
  if(((i-MaterialThickness)/toothw)%5==0){
    points.push(new THREE.Vector2(mid.x+(dir.x*i),mid.y+(dir.y*i)));
    points.push(new THREE.Vector2(mid.x+(dir.x*i)+(normalv.x*MaterialThickness*2),mid.y+(dir.y*i)+(normalv.y*MaterialThickness*2)));
    points.push(new THREE.Vector2(mid.x+(dir.x*(i+toothw))+(normalv.x*MaterialThickness*2),mid.y+(dir.y*(i+toothw))+(normalv.y*MaterialThickness*2)));
    points.push(new THREE.Vector2(mid.x+(dir.x*(i+toothw)),mid.y+(dir.y*(i+toothw))));
  }
}
}


dir.subVectors(start2,end1);
 length= dir.length();
dir.normalize();
 normalv = new THREE.Vector2(dir.y,-1*dir.x);
normalv.normalize();
points.push(end1);
if(b2){
for (var i = toothw; i < length-(2*toothw); i+=toothw) {
  if((i/toothw)%5==0){
    points.push(new THREE.Vector2(end1.x+(dir.x*i),end1.y+(dir.y*i)));
    points.push(new THREE.Vector2(end1.x+(dir.x*i)+(normalv.x*MaterialThickness*2),end1.y+(dir.y*i)+(normalv.y*MaterialThickness*2)));
    points.push(new THREE.Vector2(end1.x+(dir.x*(i+toothw))+(normalv.x*MaterialThickness*2),end1.y+(dir.y*(i+toothw))+(normalv.y*2*MaterialThickness)));
    points.push(new THREE.Vector2(end1.x+(dir.x*(i+toothw)),end1.y+(dir.y*(i+toothw))));
  }
}
}



dir.subVectors(end2,start2);
 length= dir.length();
dir.normalize();
 normalv = new THREE.Vector2(dir.y,-1*dir.x);
normalv.normalize();
points.push(start2);
if(b3){
for (var i = toothw; i < length-(2*toothw); i+=toothw) {
  if((i/toothw)%5==0){
    points.push(new THREE.Vector2(start2.x+(dir.x*i),start2.y+(dir.y*i)));
    points.push(new THREE.Vector2(start2.x+(dir.x*i)+(normalv.x*MaterialThickness*2),start2.y+(dir.y*i)+(normalv.y*MaterialThickness*2)));
    points.push(new THREE.Vector2(start2.x+(dir.x*(i+toothw))+(normalv.x*MaterialThickness*2),start2.y+(dir.y*(i+toothw))+(normalv.y*MaterialThickness*2)));
    points.push(new THREE.Vector2(start2.x+(dir.x*(i+toothw)),start2.y+(dir.y*(i+toothw))));
  }
}
}



dir.subVectors(start1,end2);
 length= dir.length();
dir.normalize();
 normalv = new THREE.Vector2(dir.y,-1*dir.x);
normalv.normalize();
points.push(end2);
if(b4){
for (var i = toothw; i < length-(2*toothw); i+=toothw) {
  if((i/toothw)%5==0){
    points.push(new THREE.Vector2(end2.x+(dir.x*i),end2.y+(dir.y*i)));
    points.push(new THREE.Vector2(end2.x+(dir.x*i)+(normalv.x*MaterialThickness*2),end2.y+(dir.y*i)+(normalv.y*MaterialThickness*2)));
    points.push(new THREE.Vector2(end2.x+(dir.x*(i+toothw))+(normalv.x*MaterialThickness*2),end2.y+(dir.y*(i+toothw))+(normalv.y*MaterialThickness*2)));
    points.push(new THREE.Vector2(end2.x+(dir.x*(i+toothw)),end2.y+(dir.y*(i+toothw))));
  }
}
}


return points;


}


function createHoles(start1,end1,start2,end2,b1,b2,b3,b4){
var holes= [];
var path= new THREE.Path();


var mid = new THREE.Vector2();

var dir = new THREE.Vector2();
dir.subVectors(end1,start1);
mid.addVectors(end1,start1);
mid.multiplyScalar(0.5);
var length= dir.length();
dir.normalize();
var points=[];
var normalv = new THREE.Vector2(dir.y,-1*dir.x);
normalv.normalize();
normalv.multiplyScalar(-1);
var normal1 =  normalv.clone();
normal1.multiplyScalar(MaterialThickness);
var normal2 = normalv.clone();
normal2.multiplyScalar(MaterialThickness*2);
var normal3 = normalv.clone();
normal3.multiplyScalar(MaterialThickness*3);
var move = dir.clone();
 move.multiplyScalar(toothw/2);
 var vmove;
 var vmove1;


//points.push(start1);
if(b1){


    points.push(new THREE.Vector2().subVectors(mid,move).add(normal2));
    points.push(new THREE.Vector2().addVectors(mid,move).add(normal2));
    points.push(new THREE.Vector2().addVectors(mid,move).add(normal1));
    points.push(new THREE.Vector2().subVectors(mid,move).add(normal1));
    var shape =new THREE.Shape(points)
    shape.autoClose=true
    holes.push(shape);
        points.length=0;
for (var i = toothw+MaterialThickness; i < (length/2)-(2*toothw); i+=toothw) {

  if(((i-MaterialThickness)/toothw)%5==0){
    vmove = dir.clone();
    vmove.multiplyScalar(-i);
    vmove1 = dir.clone();
    vmove1.multiplyScalar(-i-toothw);

  points.push(new THREE.Vector2().subVectors(mid,vmove).add(normal2));
    points.push(new THREE.Vector2().subVectors(mid,vmove1).add(normal2));
  points.push(new THREE.Vector2().subVectors(mid,vmove1).add(normal1));
  points.push(new THREE.Vector2().subVectors(mid,vmove).add(normal1));

  shape =new THREE.Shape(points)
  shape.autoClose=true
  holes.push(shape);

points.length=0;

    points.push(new THREE.Vector2().addVectors(mid,vmove).add(normal2));
      points.push(new THREE.Vector2().addVectors(mid,vmove1).add(normal2));
    points.push(new THREE.Vector2().addVectors(mid,vmove1).add(normal1));
      points.push(new THREE.Vector2().addVectors(mid,vmove).add(normal1));

        shape =new THREE.Shape(points)
        shape.autoClose=true
        holes.push(shape);
      points.length =0;

  }
}


}


dir.subVectors(start2,end1);
mid.addVectors(start2,end1);
mid.multiplyScalar(0.5);
 length= dir.length();
dir.normalize();
 normalv = new THREE.Vector2(dir.y,-1*dir.x);
normalv.normalize();
normalv.multiplyScalar(-1);
 normal1 =  normalv.clone();
normal1.multiplyScalar(MaterialThickness);
 normal2 = normalv.clone();
normal2.multiplyScalar(MaterialThickness*2);
 normal3 = normalv.clone();
normal3.multiplyScalar(MaterialThickness*3);
 move = dir.clone();
 move.multiplyScalar(toothw/2);
//points.push(end1);
if(b2){



  points.push(new THREE.Vector2().subVectors(mid,move).add(normal2));
  points.push(new THREE.Vector2().addVectors(mid,move).add(normal2));
  points.push(new THREE.Vector2().addVectors(mid,move).add(normal3));
  points.push(new THREE.Vector2().subVectors(mid,move).add(normal3));
  shape =new THREE.Shape(points)
  shape.autoClose=true
  holes.push(shape);
      points.length=0;
for (var i = toothw+MaterialThickness; i < (length/2)-(2*toothw); i+=toothw) {

if(((i-MaterialThickness)/toothw)%5==0){
  vmove = dir.clone();
  vmove.multiplyScalar(-i);
  vmove1 = dir.clone();
  vmove1.multiplyScalar(-i-toothw);

points.push(new THREE.Vector2().subVectors(mid,vmove).add(normal2));
  points.push(new THREE.Vector2().subVectors(mid,vmove1).add(normal2));
points.push(new THREE.Vector2().subVectors(mid,vmove1).add(normal3));
points.push(new THREE.Vector2().subVectors(mid,vmove).add(normal3));
points.push(new THREE.Vector2().subVectors(mid,vmove).add(normal2));
shape =new THREE.Shape(points)
shape.autoClose=true
holes.push(shape);

points.length=0;

  points.push(new THREE.Vector2().addVectors(mid,vmove).add(normal2));
    points.push(new THREE.Vector2().addVectors(mid,vmove1).add(normal2));
  points.push(new THREE.Vector2().addVectors(mid,vmove1).add(normal3));
    points.push(new THREE.Vector2().addVectors(mid,vmove).add(normal3));
      points.push(new THREE.Vector2().addVectors(mid,vmove).add(normal2));
      shape =new THREE.Shape(points)
      shape.autoClose=true
      holes.push(shape);
    points.length =0;
  }
}
}



dir.subVectors(end2,start2);
mid.addVectors(end2,start2);
mid.multiplyScalar(0.5);
 length= dir.length();
dir.normalize();
 normalv = new THREE.Vector2(dir.y,-1*dir.x);
normalv.normalize();
normalv.multiplyScalar(-1);
normal1 =  normalv.clone();
normal1.multiplyScalar(MaterialThickness);
normal2 = normalv.clone();
normal2.multiplyScalar(MaterialThickness*2);
normal3 = normalv.clone();
normal3.multiplyScalar(MaterialThickness*3);
move = dir.clone();
move.multiplyScalar(toothw/2);

if(b3){
  points.push(new THREE.Vector2().subVectors(mid,move).add(normal2));
  points.push(new THREE.Vector2().addVectors(mid,move).add(normal2));
  points.push(new THREE.Vector2().addVectors(mid,move).add(normal1));
  points.push(new THREE.Vector2().subVectors(mid,move).add(normal1));
  holes.push(new THREE.Shape(points));
      points.length=0;
for (var i = toothw+MaterialThickness; i < (length/2)-(2*toothw); i+=toothw) {

if(((i-MaterialThickness)/toothw)%5==0){
  vmove = dir.clone();
  vmove.multiplyScalar(-i);
  vmove1 = dir.clone();
  vmove1.multiplyScalar(-i-toothw);

points.push(new THREE.Vector2().subVectors(mid,vmove).add(normal2));
  points.push(new THREE.Vector2().subVectors(mid,vmove1).add(normal2));
points.push(new THREE.Vector2().subVectors(mid,vmove1).add(normal1));
points.push(new THREE.Vector2().subVectors(mid,vmove).add(normal1));

  holes.push(new THREE.Shape(points));

points.length=0;

  points.push(new THREE.Vector2().addVectors(mid,vmove).add(normal2));
    points.push(new THREE.Vector2().addVectors(mid,vmove1).add(normal2));
  points.push(new THREE.Vector2().addVectors(mid,vmove1).add(normal1));
    points.push(new THREE.Vector2().addVectors(mid,vmove).add(normal1));
    holes.push(new THREE.Shape(points));
    points.length =0;
  }
}
}



dir.subVectors(start1,end2);
mid.addVectors(start1,end2);
mid.multiplyScalar(0.5);
 length= dir.length();
dir.normalize();
 normalv = new THREE.Vector2(dir.y,-1*dir.x);
normalv.normalize();
normalv.multiplyScalar(-1);
normal1 =  normalv.clone();
normal1.multiplyScalar(MaterialThickness);
normal2 = normalv.clone();
normal2.multiplyScalar(MaterialThickness*2);
normal3 = normalv.clone();
normal3.multiplyScalar(MaterialThickness*3);
move = dir.clone();
move.multiplyScalar(toothw/2);
if(b4){


    points.push(new THREE.Vector2().subVectors(mid,move).add(normal2));
    points.push(new THREE.Vector2().addVectors(mid,move).add(normal2));
    points.push(new THREE.Vector2().addVectors(mid,move).add(normal3));
    points.push(new THREE.Vector2().subVectors(mid,move).add(normal3));
    holes.push(new THREE.Shape(points));
        points.length=0;
  for (var i = toothw+MaterialThickness; i < (length/2)-(2*toothw); i+=toothw) {

  if(((i-MaterialThickness)/toothw)%5==0){
    vmove = dir.clone();
    vmove.multiplyScalar(-i);
    vmove1 = dir.clone();
    vmove1.multiplyScalar(-i-toothw);

  points.push(new THREE.Vector2().subVectors(mid,vmove).add(normal2));
    points.push(new THREE.Vector2().subVectors(mid,vmove1).add(normal2));
  points.push(new THREE.Vector2().subVectors(mid,vmove1).add(normal3));
  points.push(new THREE.Vector2().subVectors(mid,vmove).add(normal3));

    holes.push(new THREE.Shape(points));

  points.length=0;

    points.push(new THREE.Vector2().addVectors(mid,vmove).add(normal2));
      points.push(new THREE.Vector2().addVectors(mid,vmove1).add(normal2));
    points.push(new THREE.Vector2().addVectors(mid,vmove1).add(normal3));
      points.push(new THREE.Vector2().addVectors(mid,vmove).add(normal3));
      holes.push(new THREE.Shape(points));
      points.length =0;
  }
}
}


return holes;


}

animate();
      function animate(){
        requestAnimationFrame( animate );
        if(partMode){
        render.render(scene,partcamera)
        }
        else{
          render.render(scene,camera)        }


        	// required if controls.enableDamping or controls.autoRotate are set to true
        	controls.update();



      }



      function normalizeUVs(geo){
        geo.computeBoundingBox();
        var box = geo.boundingBox;


        var min = box.min;
        var max = box.max;
        var xl = max.x-min.x;
        var yl = max.y-min.y;
        var zl = max.z-min.z;
        var lm = Math.max(xl,yl,zl);
        if(typeof(geo.attributes)=='undefined'){
          for (var i = 0; i < geo.faceVertexUvs[0].length; i++) {
console.log(geo.faceVertexUvs[0][i])
            geo.faceVertexUvs[0][i][0]=(geo.faceVertexUvs[0][i][0].divideScalar(lm*10)).addScalar(0.5);
            geo.faceVertexUvs[0][i][1]=(geo.faceVertexUvs[0][i][1].divideScalar(lm*10)).addScalar(0.5);
            geo.faceVertexUvs[0][i][2]=(geo.faceVertexUvs[0][i][2].divideScalar(lm*10)).addScalar(0.5);
console.log(geo.faceVertexUvs[0][i])
          }
        }
        else{
        for (var i = 0; i < geo.attributes.uv.array.length; i++) {

          geo.attributes.uv.array[i]=(geo.attributes.uv.array[i]/lm)+0.5;

        }
      }

      }

      function createWindow(){



      }

      function createGUI(){
        var params ={
          Height: shedH,
          Depth: shedD,
          Width: shedW,
          AngleP: propH,
          Overhang: overhang,
          BoardThickness: MaterialThickness,
          RenderMode:wireframe,
          Parts:function(){if(partMode){
            partMode= false
          }
          else{
            partMode = true;
          }
          console.log(partMode);
        }
        };
        const datGui  = new dat.GUI({ autoPlace: true });
          datGui.add(params,'Height').onChange(function(nv){

            shedH =parseFloat(nv);
            createGeom();
          });
          datGui.add(params,'Depth').onChange(function(nv){

            shedD =parseFloat(nv);
            createGeom();
          });
          datGui.add(params,'Width').onChange(function(nv){

            shedW =parseFloat(nv);
            createGeom();
          });;

          datGui.add(params,'AngleP').min(0.6).max(1).step(0.01).onChange(function(nv){

            propH =parseFloat(nv);
            createGeom();
          });;

          datGui.add(params,'Overhang').onChange(function(nv){

            overhang =parseFloat(nv);
            createGeom();
          });;
          datGui.add(params,'BoardThickness').onChange(function(nv){

            MaterialThickness =parseFloat(nv);
            createGeom();
          });;
          datGui.add(params,'RenderMode').onChange(function(nv){

            wireframe =nv ;
            console.log(typeof(nv));
            createGeom();
          });

          datGui.add(params,'Parts')
           datGui.domElement.id = 'gui'


      }

</script>


  </body>
</html>
